"""
torque_dashboard.py

Streamlit page to visualise and compare the pedalling torque generated by
commercial bicycle chainrings (oval and round).
"""
import numpy as np
import streamlit as st
import matplotlib.pyplot as plt

from simulation.chainrings_catalog import CHAINRINGS
from simulation.torque_comparison import compare_to_round
from simulation.torque_vs_timing_ovality import mean_torque_surface, mean_torque_grid
from simulation.timing_vs_ovality_deadzone import deadzone_surface, deadzone_grid


# ---------------------------------------------------------------------
st.set_page_config(
    page_title="Oval vs Round Chainring – Torque Dashboard",
    layout="wide",
)

st.title("Bike: Oval or round chainring ?")

#Sidebar controls
st.sidebar.header("Simulation parameters")
names = [c.name for c in CHAINRINGS]
selected_name = st.sidebar.selectbox("Select a chainring", names)
chainring = next(c for c in CHAINRINGS if c.name == selected_name)

cadence_rpm = st.sidebar.slider(
    "Cadence (rpm)",
    min_value=40,
    max_value=120,
    value=90,
    step=5,
    )

DEADZONE_THRESHOLD = 4.0

tab_torque, tab_deadzone, tab_surface, tab_conclusion = st.tabs(
    ["Torque", "Dead zones", "Timing & Ovality", "Conclusion"]
)

with tab_torque:
    st.subheader("Torque simulation – commercial chainrings")

    # Run simulation
    results = compare_to_round(
        chainring,
        threshold=DEADZONE_THRESHOLD,
        cadence_rpm=cadence_rpm,
    )

    # Plot torque curves
    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(
        results["angle_deg"],
        results["torque_round"],
        label="Round chainring (reference)",
    )
    ax.plot(
        results["angle_deg"],
        results["torque_oval"],
        label=f"{chainring.name}",
    )

    ax.set_xlabel("Crank angle (°)")
    ax.set_ylabel("Torque (N·m)")
    ax.legend()
    ax.grid(True)

    st.pyplot(fig)

    col1, col2, col3 = st.columns(3)
    col1.metric("Mean torque – round", f"{results['mean_torque_round']:.2f} N·m")
    col2.metric("Mean torque – selected", f"{results['mean_torque_oval']:.2f} N·m")
    col3.metric("Gain vs round", f"{results['gain_percent']:.1f} %")

with tab_deadzone:
    st.header("Dead zones analysis")
    st.write(
        f"Dead zones are defined as the regions where the pedalling torque is below {DEADZONE_THRESHOLD} N·m."
        " We aim to spent the less time possible in these zones."
    )   
    angle_round = results["angle_deg"]
    torque_round = results["torque_round"]
    torque_oval = results["torque_oval"]
    dz_round = results["deadzone_round"]
    dz_oval = results["deadzone_oval"]

    fig_dz, ax_dz = plt.subplots(figsize=(8, 4))
    ax_dz.plot(angle_round, torque_round, label="Round chainring (reference)")
    ax_dz.plot(angle_round, torque_oval, label=f"{chainring.name}")
    ax_dz.axhline(
        DEADZONE_THRESHOLD,
        color="red",
        linestyle="--",
        label="Dead zone threshold",
    )
   
    ax_dz.fill_between(
        angle_round,
        torque_round,
        DEADZONE_THRESHOLD,
        where=torque_round < DEADZONE_THRESHOLD,
        color="blue",
        interpolate=True,
        alpha=0.3,
        label="Dead zone (round)",
    )
    ax_dz.fill_between(
        angle_round,
        torque_oval,
        DEADZONE_THRESHOLD,
        where=torque_oval < DEADZONE_THRESHOLD,
        color="orange",
        alpha=0.3,
        interpolate=True,
        label="Dead zone (selected)",
    )   

    ax_dz.set_xlabel("Crank angle (°)")
    ax_dz.set_ylabel("Torque (N·m)")
    ax_dz.grid(True)
    st.pyplot(fig_dz)
    dz_round = results["deadzone_round"]
    dz_oval = results["deadzone_oval"]

    col_a, col_b = st.columns(2)
    col_a.markdown(
        f"**Round chainring**<br>"
        f"Time below threshold: {dz_round['dead_time']:.2f} s / {dz_round['total_time']:.2f} s "
        f"({dz_round['percent']:.2f} %)",
        unsafe_allow_html=True,

    )
    col_b.markdown(
        f"**{chainring.name}**<br>"
        f"Time below threshold: {dz_oval['dead_time']:.2f} s / {dz_oval['total_time']:.2f} s "
        f"({dz_oval['percent']:.2f} %)",
        unsafe_allow_html=True,
    )

    # Time spent below threshold scaled to 1 hour
    hour_dead_round = (dz_round["percent"] / 100.0) * 3600.0
    hour_dead_oval = (dz_oval["percent"] / 100.0) * 3600.0

    col_a.write(
        f"For 1h of pedaling: {hour_dead_round/60:.1f} min below the dead zone "
        f"({hour_dead_round:.0f} s)"
    )
    col_b.write(
        f"For 1h of pedaling: {hour_dead_oval/60:.1f} min below the dead zone "
        f"({hour_dead_oval:.0f} s)"
    )

    # Summary conclusion for 1 hour
    delta_hour = hour_dead_round - hour_dead_oval
    if delta_hour > 0:
        conclusion = (
            f"Conclusion: with {chainring.name}, you spend {delta_hour/60:.1f} min "
            f"({delta_hour:.0f} s) less, below the threshold over 1 hour of pedalling."
        )
    elif delta_hour < 0:
        conclusion = (
            f"Conclusion: with {chainring.name}, you spend {-delta_hour/60:.1f} min "
            f"({-delta_hour:.0f} s) more, below the threshold over 1 hour of pedalling."
        )
    else:
        conclusion = "Conclusion: both chainrings spend the same time below the threshold over 1 hour."

    st.info(conclusion)

    st.caption(
        f"Dead-zone threshold: {DEADZONE_THRESHOLD:.1f} N·m — Cadence: {cadence_rpm} rpm"
    )

with tab_surface:
    st.header("What are the best parameters possible for this chainring ?")
    st.write(
        "Each oval chainring is characterized by: \n" 
        "- its ovality (how 'oval' it is) \n "
        "- its timing (the orientation of the major axis of the oval)."
    )

    st.title("Effect of timing and ovality on mean pedalling torque")
    fig = mean_torque_surface(R=chainring.R)

    st.plotly_chart(fig, width="stretch")

    # Stats: where is mean torque maximal?
    T, O, Z = mean_torque_grid(R=chainring.R)  # T: timings, O: ovalities, Z: mean torque
    i_max, j_max = np.unravel_index(np.argmax(Z), Z.shape)
    best_timing_t = T[i_max, j_max]
    best_ovality_t = O[i_max, j_max]
    best_torque = Z[i_max, j_max]
    time_at_best_torque = Z[i_max, j_max]

    st.subheader("Maximum mean torque")
    st.write(
        f"The maximum mean torque is: **{best_torque:.2f} N·m** at "
        f"timing **{best_timing_t:.0f}°** and ovality **{best_ovality_t:.1f}%**."
    )

    st.title("Effect of timing and ovality on the time spent in dead zones")
    fig = deadzone_surface(
        R=chainring.R,
        torque_threshold=DEADZONE_THRESHOLD,
        cadence_rpm=cadence_rpm,
    )
    st.plotly_chart(fig, width="stretch")

    # Grilles : couple moyen et temps sous seuil (s/rev)
    T_t, O_t, Z_torque = mean_torque_grid(R=chainring.R)
    T_d, O_d, Z_dead = deadzone_grid(
        R=chainring.R,
        torque_threshold=DEADZONE_THRESHOLD,
        cadence_rpm=cadence_rpm,
    )

    # Min time under threshold
    i_min, j_min = np.unravel_index(np.argmin(Z_dead), Z_dead.shape)
    best_timing_d = T_d[i_min, j_min]
    best_ovality_d = O_d[i_min, j_min]
    min_time = Z_dead[i_min, j_min]
    torque_at_min_dead = Z_torque[i_min, j_min]

    st.subheader("Minimum time under dead zone")
    st.write(
        f"Best combination: timing **{best_timing_d:.0f}°**, ovality **{best_ovality_d:.1f}%** "
        f"→ time below threshold **{min_time:.3f} s per revolution** "
        f"(mean torque there: {torque_at_min_dead:.2f} N·m)."
    )
    st.subheader("Trade-off summary")
    st.write(
        f"Maximum mean torque: **{best_torque:.2f} N·m** at timing **{best_timing_t:.0f}°** "
        f"and ovality **{best_ovality_t:.1f}%**. "
        f"Dead-zone time there: **{time_at_best_torque:.3f} s/rev**."
    )

    st.write(
        f"Minimum dead-zone time: **{min_time:.2f} s/rev** at timing **{best_timing_d:.0f}°** "
        f"and ovality **{best_ovality_d:.1f}%**. "
        f"Mean torque there: **{torque_at_min_dead:.2f} N·m**."
    )

    st.write(
        "These settings differ, so there is no single ideal point — pick a compromise between "
        "maximizing mean torque and minimizing dead-zone time."
    )

    with tab_conclusion:
        st.header("Conclusion")
        st.info(
    "The simulations show that oval and round chainrings differ only marginally. "
    "Some parameter combinations (such as ovality or timing) can provide small theoretical benefits, "
    "either by increasing average torque or reducing time spent in dead zones. "
    "Oval chainrings also offer tunable parameters that may help adjust performance. "
    "However, these effects remain limited, and no chainring shape can be considered objectively superior. "
    "In practice, the choice between oval and round chainrings mostly comes down to rider preference and sensation. "
    "These results are obtained through a mechanical simulation and may not fully reflect real-world cycling conditions."
)

